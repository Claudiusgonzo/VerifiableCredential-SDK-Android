/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

require('es6-promise').polyfill();
import base64Url from 'base64url';
import 'isomorphic-fetch';
import Identifier from '../Identifier';
import IdentifierDocument from '../IdentifierDocument';
import UserAgentError from '../UserAgentError';
import UserAgentOptions from '../UserAgentOptions';
import IRegistrar from './IRegistrar';
import Multihash from './Multihash';
import { FlatJsonJws, Secp256k1CryptoSuite, CryptoFactory, JwsToken, RsaCryptoSuite } from '@decentralized-identity/did-auth-jose';
import IKeyStore from '../keystores/IKeyStore';
const cloneDeep = require('lodash/fp/cloneDeep');
declare var fetch: any;

/**
 * Registrar implementation for the Sidetree (ION) network
 */
export default class SidetreeRegistrar implements IRegistrar {
  private timeoutInMilliseconds: number;
  private serializedOptions: string;
  private keyStore: IKeyStore;

  /**
   * Constructs a new instance of the Sidetree registrar
   * @param url to the registration endpoint at the registrar
   * @param options to configure the registrar.
   */
  constructor (public url: string, options: UserAgentOptions) {
    // Set options. Stringify to avoid circular exception during serialization of this object.
    if (!(options && options.keyStore)) {
      throw new UserAgentError('options and options.keyStore need to be defined');
    }

    this.serializedOptions = JSON.stringify(options);
    this.keyStore = options.keyStore;

    // Format the url
    this.url = `${url.replace(/\/?$/, '/')}`;
    this.timeoutInMilliseconds =
      1000 *
      (!options || !options.timeoutInSeconds
        ? 30
        : options.timeoutInSeconds);
  }

  /**
   * Sign the body for the registar
   * @param body Body to sign
   */
  public async signRequest (
    body: string,
    keyStorageReference: string
  ): Promise<FlatJsonJws> {
    const cryptoFactory = new CryptoFactory([new Secp256k1CryptoSuite(), new RsaCryptoSuite()]);
    const token = new JwsToken(body, cryptoFactory);
    // Get the key
    const jwk: any = await (this.keyStore.get(keyStorageReference) as Promise<any>)
    .catch((err) => {
      throw new UserAgentError(`The key referenced by '${keyStorageReference}' is not available: '${err}'`);
    });

    switch (jwk.kty.toUpperCase()) {
      case 'RSA':
        jwk.defaultSignAlgorithm = 'RS256';
        break;

      case 'EC':
        jwk.defaultSignAlgorithm = 'ES256K';
        break;

      default:
        throw new UserAgentError(`The key type '${jwk.kty}' is not supported.`);
    }

    const signedRegistrationRequest = await token.signAsFlattenedJson(jwk, {
      header: {
        alg: jwk.defaultSignAlgorithm,
        kid: jwk.kid,
        operation: 'create',
        proofOfWork: '{}'
      }
    });
    return signedRegistrationRequest;
  }

  /**
   * Prepare the document for registration
   * @param document Document to format
   */
  public prepareDocForRegistration (document: IdentifierDocument): IdentifierDocument {
    delete document.id;
    return document;
  }

  /**
   * Registers the identifier document on the ledger
   * returning the identifier generated by the registrar.
   * @param identifierDocument to register.
   * @param keyReference Reference to the identifier for the signing key.
   */
  public async register (
    identifierDocument: IdentifierDocument,
    keyReference: string
  ): Promise<Identifier> {

    return new Promise(async (resolve, reject) => {
      const timer = setTimeout(
        () =>
          reject(new UserAgentError('Fetch timed out.')),
        this.timeoutInMilliseconds
      );

      // prepare document for registration
      identifierDocument = this.prepareDocForRegistration(identifierDocument);
      let bodyString = JSON.stringify(identifierDocument);

      // registration with signed message for bodyString
      const signedRequest = await this.signRequest(bodyString, keyReference);
      bodyString = JSON.stringify(signedRequest);

      const fetchOptions = {
        method: 'POST',
        body: bodyString,
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': bodyString.length.toString()
        }
      };

      // Now call the actual fetch with the updated options
      const response = await fetch(this.url, fetchOptions);

      // Got a response so clear the timer
      clearTimeout(timer);

      if (!response.ok) {
        const error = new UserAgentError(
          'Failed to register the identifier document.'
        );
        reject(error);
        return;
      }

      const responseJson = await response.json();
      const identifier = new Identifier(responseJson, JSON.parse(this.serializedOptions) as UserAgentOptions);
      resolve(identifier);
    });
  }

  /**
   * Uses the specified input to create a basic Sidetree
   * compliant identifier document and then hashes the document
   * in accordance with the Sidetree protocol specification
   * to generate and return the identifier.
   *
   * @param identifierDocument for which to generate the identifier.
   */
  public async generateIdentifier (identifierDocument: IdentifierDocument
  ): Promise<Identifier> {

    if (!Array.isArray(identifierDocument.publicKey) || identifierDocument.publicKey.length === 0) {
      throw new UserAgentError('At least one public key must be specified in the identifier document.');
    }

    // The genesis document is used for generating the hash,
    // but we need to ensure that the id property of the document
    // if specified is removed beforehand.
    const genesisDocument = cloneDeep(identifierDocument);
    genesisDocument.id = undefined;

    // Hash the document JSON
    const documentBuffer = Buffer.from(JSON.stringify(genesisDocument));
    const hashedDocument = Multihash.hash(documentBuffer, 18);
    const encodedDocument = base64Url.encode(hashedDocument);

    // Now update the identifier property in
    // the genesis document
    genesisDocument.id = `did:ion:${encodedDocument}`;
    return new Identifier(genesisDocument);
  }
}
